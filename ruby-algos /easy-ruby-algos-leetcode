# 1. Two Sum
# Easy
# Topics
# Companies
# Hint
# Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.

# You may assume that each input would have exactly one solution, and you may not use the same element twice.

# You can return the answer in any order.

 

# Example 1:

# Input: nums = [2,7,11,15], target = 9
# Output: [0,1]
# Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
# Example 2:

# Input: nums = [3,2,4], target = 6
# Output: [1,2]
# Example 3:

# Input: nums = [3,3], target = 6
# Output: [0,1]
 

# Constraints:

# 2 <= nums.length <= 104
# -109 <= nums[i] <= 109
# -109 <= target <= 109
# Only one valid answer exists.

# solution 1

def two_sum(nums, target)
    answer = []
    nums.each_with_index do |num1, i1|
        nums.each_with_index do |num2, i2|
            if num1 + num2 == target && i1 != i2
                answer.push(i1, i2)
                return answer
            end
        end
    end
end

# solution 1 refactored 

def two_sum(nums, target)
  # Iterate over each element in the array with its index
  nums.each_with_index do |num1, i1|
    # Iterate again over each element with its index to compare pairs
    nums.each_with_index do |num2, i2|
      # Check if the sum of the two numbers equals the target and indices are different
      if num1 + num2 == target && i1 != i2
        # Return the indices as soon as the solution is found
        return [i1, i2]
      end
    end
  end

  # Return an empty array if no solution is found
  []
end

# solution 2

def two_sum(nums, target)
  # Create a hash to store the index of each number
  index_map = {}

  # Iterate over the nums array
  nums.each_with_index do |num, index|
    # Calculate the complement needed to reach the target
    complement = target - num
    
    # Check if the complement exists in the hash
    if index_map.key?(complement)
      # If found, return the indices
      return [index_map[complement], index]
    end
    
    # Store the current number and its index in the hash
    index_map[num] = index
  end

  # In case there's no solution, return nil or an empty array
  return []
end


# 14. Longest Common Prefix
# Easy
# Topics
# Companies
# Write a function to find the longest common prefix string amongst an array of strings.

# If there is no common prefix, return an empty string "".

# Example 1:

# Input: strs = ["flower","flow","flight"]
# Output: "fl"
# Example 2:

# Input: strs = ["dog","racecar","car"]
# Output: ""
# Explanation: There is no common prefix among the input strings.

# Constraints:

# 1 <= strs.length <= 200
# 0 <= strs[i].length <= 200
# strs[i] consists of only lowercase English letters.

def longest_common_prefix(strs)
  prefix = ''
  index = 0
  test_chars = strs[0].split('')
  print test_chars
  strs.shift
  strs.each do |str|
    if str[index] == test_chars[index] && !prefix.include?(test_chars[index])
      prefix << test_chars[index]
      index += 1
    elsif str[index] == test_chars[index] && prefix.include?(test_chars[index])
      index += 1
    else
      break
    end
  end
  prefix
end

# 88. Merge Sorted Array
# Easy
# Topics
# Companies
# Hint
# You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.

# Merge nums1 and nums2 into a single array sorted in non-decreasing order.

# The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.

# Example 1:

# Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
# Output: [1,2,2,3,5,6]
# Explanation: The arrays we are merging are [1,2,3] and [2,5,6].
# The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.
# Example 2:

# Input: nums1 = [1], m = 1, nums2 = [], n = 0
# Output: [1]
# Explanation: The arrays we are merging are [1] and [].
# The result of the merge is [1].
# Example 3:

# Input: nums1 = [0], m = 0, nums2 = [1], n = 1
# Output: [1]
# Explanation: The arrays we are merging are [] and [1].
# The result of the merge is [1].
# Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.

# Constraints:

# nums1.length == m + n
# nums2.length == n
# 0 <= m, n <= 200
# 1 <= m + n <= 200
# -109 <= nums1[i], nums2[j] <= 109

def merge(nums1, _m, nums2, _n)
  nums2.each { |i| nums1.push(i) }
  nums1.delete_if { |char| char == 0 }
  nums1.sort!
end

# 217. Contains Duplicate
# Easy
# Topics
# Companies
# Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.

# Example 1:

# Input: nums = [1,2,3,1]
# Output: true
# Example 2:

# Input: nums = [1,2,3,4]
# Output: false
# Example 3:

# Input: nums = [1,1,1,3,3,4,3,2,4,2]
# Output: true

# Constraints:

# 1 <= nums.length <= 105
# -109 <= nums[i] <= 109

def contains_duplicate(nums)
  nums.each do |i|
    nums.shift
    return true if nums.include?(i)

    return false
  end
end

# 520. Detect Capital
# Easy
# Topics
# Companies
# We define the usage of capitals in a word to be right when one of the following cases holds:

# All letters in this word are capitals, like "USA".
# All letters in this word are not capitals, like "leetcode".
# Only the first letter in this word is capital, like "Google".
# Given a string word, return true if the usage of capitals in it is right.

# Example 1:

# Input: word = "USA"
# Output: true
# Example 2:

# Input: word = "FlaG"
# Output: false

# Constraints:

# 1 <= word.length <= 100
# word consists of lowercase and uppercase English letters.

def detect_capital_use(word)
  cap_count = 0
  wrd_ary = word.split('')
  wrd_ary.each do |char|
    cap_count += 1 if char === char.upcase
  end
  puts "wrd_ary: #{wrd_ary}"
  puts "cap_count: #{cap_count}"
  puts "ap_count = wrd_ary.length: #{ap_count = wrd_ary.length}"
  puts "wrd_ary[0] === wrd_ary[0].upcase: #{wrd_ary[0] === wrd_ary[0].upcase}"
  if (cap_count == 0) ||
     (wrd_ary[0] === wrd_ary[0].upcase && cap_count == wrd_ary.length) ||
     (wrd_ary[0] === wrd_ary[0].upcase && cap_count == 1)
    true
  else
    false
  end
end

# 796. Rotate String
# Easy
# Topics
# Companies
# Given two strings s and goal, return true if and only if s can become goal after some number of shifts on s.

# A shift on s consists of moving the leftmost character of s to the rightmost position.

# For example, if s = "abcde", then it will be "bcdea" after one shift.

# Example 1:

# Input: s = "abcde", goal = "cdeab"
# Output: true
# Example 2:

# Input: s = "abcde", goal = "abced"
# Output: false

# Constraints:

# 1 <= s.length, goal.length <= 100
# s and goal consist of lowercase English letters.

# solution 1

def rotate_string(s, goal)
  str_to_a = s.split('')
  puts "str_to_a #{str_to_a}"
  puts "str_to_a.join #{str_to_a.join('')}"
  puts "str_to_a.to_s #{str_to_a}"
  index = 0
  until str_to_a.join('') == goal || index > str_to_a.length
    str_to_a.push(str_to_a[0])
    str_to_a.shift
    index += 1
  end
  if index > str_to_a.length
    false
  elsif str_to_a.join('') == goal
    true
  end
end

# solution 2

def rotate_string(s, goal)
  return false if s.length != goal.length # Early exit if lengths are different

  (s + s).include?(goal)
end

# 58. Length of Last Word
# Easy
# Topics
# Companies
# Given a string s consisting of words and spaces, return the length of the last word in the string.

# A word is a maximal
# substring
#  consisting of non-space characters only.

# Example 1:

# Input: s = "Hello World"
# Output: 5
# Explanation: The last word is "World" with length 5.
# Example 2:

# Input: s = "   fly me   to   the moon  "
# Output: 4
# Explanation: The last word is "moon" with length 4.
# Example 3:

# Input: s = "luffy is still joyboy"
# Output: 6
# Explanation: The last word is "joyboy" with length 6.

# Constraints:

# 1 <= s.length <= 104
# s consists of only English letters and spaces ' '.
# There will be at least one word in s.

# solution 1

def length_of_last_word(s)
  # s_array = s.split(' ')
  # last_word = s_array.pop()
  # lst_wrd_lngth = last_word.length
  # return lst_wrd_lngth
end

# solution 1 refactor

def length_of_last_word(s)
  s.split(' ').pop.length
end

# 26. Remove Duplicates from Sorted Array
# Easy
# Topics
# Companies
# Hint
# Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.

# Consider the number of unique elements of nums to be k, to get accepted, you need to do the following things:

# Change the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums.
# Return k.
# Custom Judge:

# The judge will test your solution with the following code:

# int[] nums = [...]; // Input array
# int[] expectedNums = [...]; // The expected answer with correct length

# int k = removeDuplicates(nums); // Calls your implementation

# assert k == expectedNums.length;
# for (int i = 0; i < k; i++) {
#     assert nums[i] == expectedNums[i];
# }
# If all assertions pass, then your solution will be accepted.

# Example 1:

# Input: nums = [1,1,2]
# Output: 2, nums = [1,2,_]
# Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.
# It does not matter what you leave beyond the returned k (hence they are underscores).
# Example 2:

# Input: nums = [0,0,1,1,1,2,2,3,3,4]
# Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]
# Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.
# It does not matter what you leave beyond the returned k (hence they are underscores).

# solution 1

def remove_duplicates(nums)
  index = 0
  num = ''
  inx_ary = []
  nums.each do |i|
    if i === num
      inx_ary.push(index)
    else
      num = i
    end
    index += 1
  end

  inx_ary.reverse.each do |inx|
    nums.delete_at(inx)
  end

  nums.length
end

# solution 2

def remove_duplicates(nums)
  return 0 if nums.empty?

  write_index = 1

  (1...nums.length).each do |read_index|
    if nums[read_index] != nums[read_index - 1]
      nums[write_index] = nums[read_index]
      write_index += 1
    end
  end

  write_index
end

# 35. Search Insert Position
# Easy
# Topics
# Companies
# Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

# You must write an algorithm with O(log n) runtime complexity.

# Example 1:

# Input: nums = [1,3,5,6], target = 5
# Output: 2
# Example 2:

# Input: nums = [1,3,5,6], target = 2
# Output: 1
# Example 3:

# Input: nums = [1,3,5,6], target = 7
# Output: 4

# Constraints:

# 1 <= nums.length <= 104
# -104 <= nums[i] <= 104
# nums contains distinct values sorted in ascending order.
# -104 <= target <= 104

# solution

def search_insert(nums, target)
  return nums.length if nums[nums.length - 1] < target

  nums.each do |i|
    return nums.index(i) if i >= target
  end
end

# 70. Climbing Stairs
# Easy
# Topics
# Companies
# Hint
# You are climbing a staircase. It takes n steps to reach the top.

# Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

# Example 1:

# Input: n = 2
# Output: 2
# Explanation: There are two ways to climb to the top.
# 1. 1 step + 1 step
# 2. 2 steps
# Example 2:

# Input: n = 3
# Output: 3
# Explanation: There are three ways to climb to the top.
# 1. 1 step + 1 step + 1 step
# 2. 1 step + 2 steps
# 3. 2 steps + 1 step

# Constraints:

1 <= n && n

# solution

def climb_stairs(n)
  return 1 if n == 1
  return 2 if n == 2

  # Initialize base cases
  ways = Array.new(n + 1)
  ways[1] = 1
  ways[2] = 2

  # Fill the array using the recurrence relation
  (3..n).each do |i|
    ways[i] = ways[i - 1] + ways[i - 2]
  end

  # The answer is in ways[n]
  ways[n]
end

# 3151. Special Array I
# Easy
# Topics
# Companies
# Hint
# An array is considered special if every pair of its adjacent elements contains two numbers with different parity.

# You are given an array of integers nums. Return true if nums is a special array, otherwise, return false.

# Example 1:

# Input: nums = [1]

# Output: true

# Explanation:

# There is only one element. So the answer is true.

# Example 2:

# Input: nums = [2,1,4]

# Output: true

# Explanation:

# There is only two pairs: (2,1) and (1,4), and both of them contain numbers with different parity. So the answer is true.

# Example 3:

# Input: nums = [4,3,1,6]

# Output: false

# Explanation:

# nums[1] and nums[2] are both odd. So the answer is false.

# Constraints:

# 1 <= nums.length <= 100
# 1 <= nums[i] <= 100

# solution 1

def is_array_special(nums)
  return true if nums.length == 1

  char = ''
  nums.each do |i|
    if char === ''
      char = i
    elsif (char.even? && i.even?) ||
          (char.odd? && i.odd?)
      return false
    else
      char = i
    end
  end
  true
end

# solution 1 refactor

def is_array_special(nums)
  return true if nums.length == 1

  nums.each_cons(2) do |a, b|
    return false if (a.even? && b.even?) || (a.odd? && b.odd?)
  end

  true
end

# 3174. Clear Digits
# Easy
# Topics
# Companies
# Hint
# You are given a string s.

# Your task is to remove all digits by doing this operation repeatedly:

# Delete the first digit and the closest non-digit character to its left.
# Return the resulting string after removing all digits.

# Example 1:

# Input: s = "abc"

# Output: "abc"

# Explanation:

# There is no digit in the string.

# Example 2:

# Input: s = "cb34"

# Output: ""

# Explanation:

# First, we apply the operation on s[2], and s becomes "c4".

# Then we apply the operation on s[1], and s becomes "".

# Constraints:

# 1 <= s.length <= 100
# s consists only of lowercase English letters and digits.
# The input is generated such that it is possible to delete all digits.

# solution 1

def clear_digits(s)
  s_ary = s.split('')
  ary = []
  index = 0
  disp_idx = 0
  s_ary.each do |char|
    if ('0'..'9').include?(char)
      puts "char = int?: #{('0'..'9').include?(char)}"
      ary.push(index)
    end
    index += 1
    puts "index: #{index}"
  end
  puts "ary: #{ary}"
  ary.each do |idx|
    s_ary.delete_at(idx - disp_idx)
    s_ary.delete_at(idx - disp_idx - 1)
    disp_idx += 2
    puts "s_ary: #{s_ary}"
  end
  s_ary.join('')
end

# solution 1 refactor

def clear_digits(s)
  s_ary = s.chars
  digit_indices = []

  s_ary.each_with_index do |char, index|
    digit_indices << index if char.match?(/[0-9]/)
  end

  # Delete digits and their left non-digit characters
  digit_indices.reverse.each do |idx|
    s_ary.delete_at(idx) # Remove the digit
    s_ary.delete_at(idx - 1) if idx > 0 # Remove the closest non-digit to its left
  end

  s_ary.join('')
end

# slution 2

def clear_digits(s)
  stack = []

  s.each_char do |char|
    if char.match?(/[0-9]/)
      stack.pop if stack.any? # Remove the closest non-digit to its left
    else
      stack.push(char) # Add non-digit character to the stack
    end
  end

  stack.join('')
end

# 20. Valid Parentheses
# Easy
# Topics
# Companies
# Hint
# Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

# An input string is valid if:

# Open brackets must be closed by the same type of brackets.
# Open brackets must be closed in the correct order.
# Every close bracket has a corresponding open bracket of the same type.

# Example 1:

# Input: s = "()"
# Output: true
# Example 2:

# Input: s = "()[]{}"
# Output: true
# Example 3:

# Input: s = "(]"
# Output: false

# Constraints:

# 1 <= s.length <= 104
# s consists of parentheses only '()[]{}'.

# solution 1

def is_valid(s)
  # Define a hash to map closing brackets to their corresponding opening brackets
  bracket_pairs = {
    ')' => '(',
    '}' => '{',
    ']' => '['
  }

  # Initialize an empty stack
  stack = []

  # Iterate through each character in the string
  s.each_char do |char|
    if bracket_pairs.values.include?(char)  # Check if it's an opening bracket
      stack.push(char)
    elsif bracket_pairs.keys.include?(char) # Check if it's a closing bracket
      return false if stack.empty? || stack.pop != bracket_pairs[char]
    end
  end

  # If the stack is empty, all opening brackets have been matched and closed properly
  stack.empty?
end

# 18. 4Sum
# Medium
# Topics
# Companies
# Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:

# 0 <= a, b, c, d < n
# a, b, c, and d are distinct.
# nums[a] + nums[b] + nums[c] + nums[d] == target
# You may return the answer in any order.

# Example 1:

# Input: nums = [1,0,-1,0,-2,2], target = 0
# Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
# Example 2:

# Input: nums = [2,2,2,2,2], target = 8
# Output: [[2,2,2,2]]

# Constraints:

# 1 <= nums.length <= 200
# -109 <= nums[i] <= 109
# -109 <= target <= 109

# solution 1

def four_sum(nums, target)
  answer = []
  combos = nums.combination(4).to_a
  combos.each do |combo|
    combo_sum = 0
    combo.each do |i|
      combo_sum += i
    end
    answer.push(combo) if combo_sum == target && !answer.include?(combo)
  end
  answer
end

# solution 1 refactored

def four_sum(nums, target)
  answer = []
  nums.combination(4).each do |combo|
    answer.push(combo.sort) if combo.sum == target && !answer.include?(combo.sort)
  end
  answer
end

# solution 2

def four_sum(nums, target)
  nums.sort!
  n = nums.size
  answer = []

  (0...n - 3).each do |i|
    next if i > 0 && nums[i] == nums[i - 1]

    (i + 1...n - 2).each do |j|
      next if j > i + 1 && nums[j] == nums[j - 1]

      left = j + 1
      right = n - 1

      while left < right
        sum = nums[i] + nums[j] + nums[left] + nums[right]

        if sum == target
          answer << [nums[i], nums[j], nums[left], nums[right]]
          left += 1
          right -= 1
          left += 1 while left < right && nums[left] == nums[left - 1]
          right -= 1 while left < right && nums[right] == nums[right + 1]
        elsif sum < target
          left += 1
        else
          right -= 1
        end
      end
    end
  end

  answer
end

# 15. 3Sum
# Medium
# Topics
# Companies
# Hint
# Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.

# Notice that the solution set must not contain duplicate triplets.

# Example 1:

# Input: nums = [-1,0,1,2,-1,-4]
# Output: [[-1,-1,2],[-1,0,1]]
# Explanation:
# nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.
# nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.
# nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.
# The distinct triplets are [-1,0,1] and [-1,-1,2].
# Notice that the order of the output and the order of the triplets does not matter.
# Example 2:

# Input: nums = [0,1,1]
# Output: []
# Explanation: The only possible triplet does not sum up to 0.
# Example 3:

# Input: nums = [0,0,0]
# Output: [[0,0,0]]
# Explanation: The only possible triplet sums up to 0.

# Constraints:

# 3 <= nums.length <= 3000
# -105 <= nums[i] <= 105

# solution 1

def three_sum(nums)
  answer = []
  nums.combination(3).each do |combo|
    answer.push(combo.sort) if combo.sum == 0 && !answer.include?(combo.sort)
  end
  answer
end

# solution 2

def three_sum(nums)
  nums.sort!
  n = nums.size
  answer = []

  (0...n - 2).each do |i|
    next if i > 0 && nums[i] == nums[i - 1]

    left = i + 1
    right = n - 1

    while left < right
      sum = nums[i] + nums[left] + nums[right]

      if sum == 0
        answer << [nums[i], nums[left], nums[right]]
        left += 1
        right -= 1
        left += 1 while left < right && nums[left] == nums[left - 1]
        right -= 1 while left < right && nums[right] == nums[right + 1]
      elsif sum < 0
        left += 1
      else
        right -= 1
      end
    end
  end

  answer
end

# 16. 3Sum Closest
# Medium
# Topics
# Companies
# Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.

# Return the sum of the three integers.

# You may assume that each input would have exactly one solution.

# Example 1:

# Input: nums = [-1,2,1,-4], target = 1
# Output: 2
# Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
# Example 2:

# Input: nums = [0,0,0], target = 1
# Output: 0
# Explanation: The sum that is closest to the target is 0. (0 + 0 + 0 = 0).

# Constraints:

# 3 <= nums.length <= 500
# -1000 <= nums[i] <= 1000
# -104 <= target <= 104

# solution 1

def three_sum_closest(nums, target)
  nums.sort!
  n = nums.length
  answer = nums[0] + nums[1] + nums[2]

  (0...n - 2).each do |i|
    left = i + 1
    right = n - 1

    while left < right
      sum = nums[i] + nums[left] + nums[right]

      answer = sum if (target - sum).abs < (target - answer).abs

      if sum == target
        return sum
      elsif sum < target
        left += 1
      else
        right -= 1
      end
    end
  end
  answer
end

# 17. Letter Combinations of a Phone Number
# Medium
# Topics
# Companies
# Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.

# A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.

# Example 1:

# Input: digits = "23"
# Output: ["ad","ae","af","bd","be","bf","cd","ce","cf"]
# Example 2:

# Input: digits = ""
# Output: []
# Example 3:

# Input: digits = "2"
# Output: ["a","b","c"]

# Constraints:

# 0 <= digits.length <= 4
# digits[i] is a digit in the range ['2', '9'].

# solution 1

def letter_combinations(digits)
  return [] if digits.empty?

  combos = {
    '2' => 'abc',
    '3' => 'def',
    '4' => 'ghi',
    '5' => 'jkl',
    '6' => 'mno',
    '7' => 'pqrs',
    '8' => 'tuv',
    '9' => 'wxyz'
  }

  answer = []

  def backtrack(combination, next_digits, combos, answer)
    if next_digits.empty?
      answer << combination
    else
      digit = next_digits[0]
      letters = combos[digit]
      letters.each_char do |letter|
        backtrack(combination + letter, next_digits[1..-1], combos, answer)
      end
    end
  end

  backtrack('', digits, combos, answer)
  answer
end

# 22. Generate Parentheses
# Medium
# Topics
# Companies
# Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

# Example 1:

# Input: n = 3
# Output: ["((()))","(()())","(())()","()(())","()()()"]
# Example 2:

# Input: n = 1
# Output: ["()"]

# Constraints:

# 1 <= n <= 8

# solution 1 recursive

def generate_parenthesis(n)
  result = []

  def backtrack(result, current, open_count, close_count, max)
    # Base case: if the current combination is complete
    if current.length == max * 2
      result << current
      return
    end

    # If we can add an open parenthesis, add it and recurse
    backtrack(result, current + '(', open_count + 1, close_count, max) if open_count < max

    # If we can add a close parenthesis, add it and recurse
    return unless close_count < open_count

    backtrack(result, current + ')', open_count, close_count + 1, max)
  end

  # Start the backtracking process with an empty combination
  backtrack(result, '', 0, 0, n)

  result
end

# solution 2 iterative

def generate_parentheses(n)
  result = []
  queue = [['', 0, 0]]

  until queue.empty?
    current, open_count, close_count = queue.shift

    if open_count == n && close_count == n
      result << current
    else
      queue.push([current + '(', open_count + 1, close_count]) if open_count < n

      queue.push([current + ')', open_count, close_count + 1]) if close_count < open_count
    end
  end

  result
end

# 412. Fizz Buzz
# Easy
# Topics
# Companies
# Given an integer n, return a string array answer (1-indexed) where:

# answer[i] == "FizzBuzz" if i is divisible by 3 and 5.
# answer[i] == "Fizz" if i is divisible by 3.
# answer[i] == "Buzz" if i is divisible by 5.
# answer[i] == i (as a string) if none of the above conditions are true.

# Example 1:

# Input: n = 3
# Output: ["1","2","Fizz"]
# Example 2:

# Input: n = 5
# Output: ["1","2","Fizz","4","Buzz"]
# Example 3:

# Input: n = 15
# Output: ["1","2","Fizz","4","Buzz","Fizz","7","8","Fizz","Buzz","11","Fizz","13","14","FizzBuzz"]

# Constraints:

# 1 <= n <= 104

# solution 1

def fizz_buzz(n)
  # create empty answer array
  answer = []
  # iterate through range 1...n
  for i in 1...n + 1
    # check if n is divisible by 3, 5, both or none
    # depending what condition is met, .push the appropriate
    # integer(as string), or Fizz, Bar or both.
    if i % 3 == 0 && i % 5 == 0
      answer.push('FizzBuzz')
    elsif i % 3 == 0 && i % 5 != 0
      answer.push('Fizz')
    elsif i % 5 == 0 && i % 3 != 0
      answer.push('Buzz')
    else
      answer.push("#{i}")
    end
  end
  # return answer
  answer
end

# solution 1 refactored

def fizz_buzz(n)
  # create empty answer array
  answer = []
  # iterate through range 1...n
  for i in 1...n + 1
    # check if n is divisible by 3, 5, both or none
    # depending what condition is met, .push the appropriate
    # integer(as string), or Fizz, Bar or both.
    if i % 3 == 0 && i % 5 == 0
      answer.push('FizzBuzz')
    elsif i % 3 == 0 && i % 5 != 0
      answer.push('Fizz')
    elsif i % 5 == 0 && i % 3 != 0
      answer.push('Buzz')
    else
      answer.push("#{i}")
    end
  end
  # return answer
  answer
end

# solution 2

def fizz_buzz(n)
  (1..n).map do |i|
    result = ''
    result += 'Fizz' if i % 3 == 0
    result += 'Buzz' if i % 5 == 0
    result.empty? ? i.to_s : result
  end
end

# 242. Valid Anagram
# Easy
# Topics
# Companies
# Given two strings s and t, return true if t is an anagram of s, and false otherwise.

# An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

# Example 1:

# Input: s = "anagram", t = "nagaram"
# Output: true
# Example 2:

# Input: s = "rat", t = "car"
# Output: false

# Constraints:

# 1 <= s.length, t.length <= 5 * 104
# s and t consist of lowercase English letters.

# solution 1

def is_anagram(s, t)
  s_sorted = s.split('').sort
  t_sorted = t.split('').sort
  return true if s_sorted == t_sorted

  false
end

# solution 1 refactored

def is_anagram(s, t)
  s.chars.sort == t.chars.sort
end

# solution 2(not efficient with nested loop)

def is_anagram(s, t)
  s.each_char do |char1|
    t.each_char do |char2|
      if char1 == char2
        s.delete! char1
        t.delete! char2
      end
    end
  end
  return true if s.empty? == true && t.empty? == true

  false
end

# solution 3

def is_anagram(s, t)
  return false if s.length != t.length

  s_freq = Hash.new(0)
  t_freq = Hash.new(0)

  s.each_char { |char| s_freq[char] += 1 }
  t.each_char { |char| t_freq[char] += 1 }

  s_freq == t_freq
end

# solution 3 refactored

def is_anagram(s, t)
  return false if s.length != t.length

  char_count = Hash.new(0)

  s.each_char { |char| char_count[char] += 1 }
  t.each_char { |char| char_count[char] -= 1 }

  char_count.all? { |_, count| count == 0 }
end

# 268. Missing Number
# Easy
# Topics
# Companies
# Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.

# Example 1:

# Input: nums = [3,0,1]
# Output: 2
# Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.
# Example 2:

# Input: nums = [0,1]
# Output: 2
# Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.
# Example 3:

# Input: nums = [9,6,4,2,3,5,7,0,1]
# Output: 8
# Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.

# Constraints:

# n == nums.length
# 1 <= n <= 104
# 0 <= nums[i] <= n
# All the numbers of nums are unique.

# solution 1
def missing_number(nums)
  (0..nums.length).each do |i|
    return i unless nums.include?(i)
  end
end

# solution 2

def missing_number(nums)
  n = nums.length
  expected_sum = n * (n + 1) / 2
  actual_sum = nums.sum
  expected_sum - actual_sum
end

# 485. Max Consecutive Ones
# Easy
# Topics
# Companies
# Hint
# Given a binary array nums, return the maximum number of consecutive 1's in the array.

# Example 1:

# Input: nums = [1,1,0,1,1,1]
# Output: 3
# Explanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3.
# Example 2:

# Input: nums = [1,0,1,1,0,1]
# Output: 2

# Constraints:

# 1 <= nums.length <= 105
# nums[i] is either 0 or 1.

# solution 1

def find_max_consecutive_ones(nums)
  answer = 0
  counter = 0
  nums.each do |i|
    if i == 1
      counter += 1
      answer = counter if counter > answer
    else
      counter = 0
    end
  end
  answer
end

# solution 1 refactor

def find_max_consecutive_ones(nums)
  max_count = 0
  current_count = 0

  nums.each do |num|
    if num == 1
      current_count += 1
      max_count = [max_count, current_count].max
    else
      current_count = 0
    end
  end

  max_count
end

# solution 2

def find_max_consecutive_ones(nums)
  nums.join.split('0').map(&:length).max
end

# 500. Keyboard Row
# Easy
# Topics
# Companies
# Given an array of strings words, return the words that can be typed using letters of the alphabet on only one row of American keyboard like the image below.

# In the American keyboard:

# the first row consists of the characters "qwertyuiop",
# the second row consists of the characters "asdfghjkl", and
# the third row consists of the characters "zxcvbnm".

# Example 1:

# Input: words = ["Hello","Alaska","Dad","Peace"]
# Output: ["Alaska","Dad"]
# Example 2:

# Input: words = ["omk"]
# Output: []
# Example 3:

# Input: words = ["adsdf","sfd"]
# Output: ["adsdf","sfd"]

# Constraints:

# 1 <= words.length <= 20
# 1 <= words[i].length <= 100
# words[i] consists of English letters (both lowercase and uppercase).

# solution 1

def find_words(words)
  row1 = 'qwertyuiop'
  row2 = 'asdfghjkl'
  row3 = 'zxcvbnm'

  answer = []

  words.each do |word|
    wrd_row = 0
    char_row = 0
    valid = true

    word.each_char do |char|
      char = char.downcase # To handle case insensitivity

      if wrd_row == 0 && row1.include?(char)
        wrd_row = 1
        char_row = 1
      elsif wrd_row == 0 && row2.include?(char)
        wrd_row = 2
        char_row = 2
      elsif wrd_row == 0 && row3.include?(char)
        wrd_row = 3
        char_row = 3
      elsif wrd_row > 0 && row1.include?(char)
        char_row = 1
      elsif wrd_row > 0 && row2.include?(char)
        char_row = 2
      elsif wrd_row > 0 && row3.include?(char)
        char_row = 3
      end

      if wrd_row != char_row
        valid = false
        break
      end
    end

    answer.push(word) if valid
  end

  answer
end

# solution 2

def find_words(words)
  row1 = Set.new('qwertyuiop')
  row2 = Set.new('asdfghjkl')
  row3 = Set.new('zxcvbnm')

  answer = []

  words.each do |word|
    downcased_word = word.downcase
    first_char = downcased_word[0]

    target_row = if row1.include?(first_char)
                   row1
                 elsif row2.include?(first_char)
                   row2
                 else
                   row3
                 end

    answer.push(word) if downcased_word.chars.all? { |char| target_row.include?(char) }
  end

  answer
end

# solution 3

def find_words(words)
  rows = {
    'q' => 1, 'w' => 1, 'e' => 1, 'r' => 1, 't' => 1, 'y' => 1, 'u' => 1, 'i' => 1, 'o' => 1, 'p' => 1,
    'a' => 2, 's' => 2, 'd' => 2, 'f' => 2, 'g' => 2, 'h' => 2, 'j' => 2, 'k' => 2, 'l' => 2,
    'z' => 3, 'x' => 3, 'c' => 3, 'v' => 3, 'b' => 3, 'n' => 3, 'm' => 3
  }

  answer = []

  words.each do |word|
    downcased_word = word.downcase
    first_row = rows[downcased_word[0]]

    answer.push(word) if downcased_word.chars.all? { |char| rows[char] == first_row }
  end

  answer
end

# 290. Word Pattern
# Easy
# Topics
# Companies
# Given a pattern and a string s, find if s follows the same pattern.

# Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.

# Example 1:

# Input: pattern = "abba", s = "dog cat cat dog"
# Output: true
# Example 2:

# Input: pattern = "abba", s = "dog cat cat fish"
# Output: false
# Example 3:

# Input: pattern = "aaaa", s = "dog cat cat dog"
# Output: false

# Constraints:

# 1 <= pattern.length <= 300
# pattern contains only lower-case English letters.
# 1 <= s.length <= 3000
# s contains only lowercase English letters and spaces ' '.
# s does not contain any leading or trailing spaces.
# All the words in s are separated by a single space.

# solution 1 has problems

def word_pattern(pattern, s)
  pattern = pattern.split('')
  s = s.split(' ')

  tracker = {}

  return false if pattern.length != s.length

  (0..pattern.length).each do |i|
    if !tracker.include?(pattern[i]) && !tracker.include?(s[i])
      tracker[pattern[i]] = s[i]
    elsif tracker.include?(pattern[i]) && tracker[pattern[i]] != s[i]
      return false
    end
  end
  true
end

# solution 1 fixed with one hash

def word_pattern(pattern, s)
  pattern = pattern.split('')
  s = s.split(' ')

  return false if pattern.length != s.length

  tracker = {}

  pattern.each_with_index do |char, i|
    if !tracker.include?(char) && !tracker.value?(s[i])
      tracker[char] = s[i]
    elsif tracker.include?(char) && tracker[char] != s[i]
      return false
    end
  end

  true
end

# solution 1 fixed with 2 hashes

def word_pattern(pattern, s)
  pattern = pattern.split('')
  s = s.split(' ')

  tracker = {}

  return false if pattern.length != s.length

  (0..pattern.length).each do |i|
    if !tracker.include?(pattern[i]) && !tracker.include?(s[i])
      tracker[pattern[i]] = s[i]
    elsif tracker.include?(pattern[i]) && tracker[pattern[i]] != s[i]
      return false
    end
  end
  true
end

# 392. Is Subsequence
# Easy
# Topics
# Companies
# Given two strings s and t, return true if s is a subsequence of t, or false otherwise.

# A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., "ace" is a subsequence of "abcde" while "aec" is not).

# Example 1:

# Input: s = "abc", t = "ahbgdc"
# Output: true
# Example 2:

# Input: s = "axc", t = "ahbgdc"
# Output: false

# Constraints:

# 0 <= s.length <= 100
# 0 <= t.length <= 104
# s and t consist only of lowercase English letters.

# solution 1 inefficient

def is_subsequence(s, t)
  t.chars do |char|
    t.delete! char unless s.include?(char)
  end
  s == t
end

# solution 2

def is_subsequence(s, t)
  s_index = 0
  t.each_char do |char|
    s_index += 1 if char == s[s_index]
    return true if s_index == s.length
  end
  s_index == s.length
end

# 383. Ransom Note
# Easy
# Topics
# Companies
# Given two strings ransomNote and magazine, return true if ransomNote can be constructed by using the letters from magazine and false otherwise.

# Each letter in magazine can only be used once in ransomNote.

# Example 1:

# Input: ransomNote = "a", magazine = "b"
# Output: false
# Example 2:

# Input: ransomNote = "aa", magazine = "ab"
# Output: false
# Example 3:

# Input: ransomNote = "aa", magazine = "aab"
# Output: true

# Constraints:

# 1 <= ransomNote.length, magazine.length <= 105
# ransomNote and magazine consist of lowercase English letters.

# solution 1

def can_construct(ransom_note, magazine)
  ransom_note.chars do |letter|
    return false unless magazine.include?(letter)

    magazine.sub!(letter, '')
  end
  true
end

# solution 2

def can_construct(ransom_note, magazine)
  magazine_counts = Hash.new(0)

  # Count frequency of each character in magazine
  magazine.chars.each do |char|
    magazine_counts[char] += 1
  end

  # Check if ransom_note can be constructed
  ransom_note.chars.each do |char|
    return false if magazine_counts[char] == 0

    magazine_counts[char] -= 1
  end

  true
end

# 345. Reverse Vowels of a String
# Easy
# Topics
# Companies
# Given a string s, reverse only all the vowels in the string and return it.

# The vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both lower and upper cases, more than once.

# Example 1:

# Input: s = "hello"
# Output: "holle"
# Example 2:

# Input: s = "leetcode"
# Output: "leotcede"

# Constraints:

# 1 <= s.length <= 3 * 105
# s consist of printable ASCII characters.

# solution 1

def reverse_vowels(s)
  vowels = 'aeiou'
  vwl_ary = []
  s.chars do |letter|
    if vowels.include?(letter)
      vwl_ary.push(letter)
      s.sub!(letter, '!')
    end
  end
  vwl_ary.reverse.each do |letter|
    s.sub!('!', letter)
  end
  s
end

# solution 2

def reverse_vowels(s)
  vowels = 'aeiouAEIOU'
  left = 0
  right = s.length - 1
  s_chars = s.chars

  while left < right
    left += 1 while left < right && !vowels.include?(s_chars[left])
    right -= 1 while left < right && !vowels.include?(s_chars[right])

    next unless left < right

    s_chars[left], s_chars[right] = s_chars[right], s_chars[left]
    left += 1
    right -= 1
  end

  s_chars.join
end

# 461. Hamming Distance
# Easy
# Topics
# Companies
# The Hamming distance between two integers is the number of positions at which the corresponding bits are different.

# Given two integers x and y, return the Hamming distance between them.

# Example 1:

# Input: x = 1, y = 4
# Output: 2
# Explanation:
# 1   (0 0 0 1)
# 4   (0 1 0 0)
#        ↑   ↑
# The above arrows point to positions where the corresponding bits are different.
# Example 2:

# Input: x = 3, y = 1
# Output: 1

# Constraints:

# 0 <= x, y <= 231 - 1

# solution 1
def hamming_distance(x, y)
  # Convert both numbers to binary strings
  bin_x = x.to_s(2)
  bin_y = y.to_s(2)

  # Find the lengths of the binary strings
  len_x = bin_x.length
  len_y = bin_y.length

  # Manually pad the shorter string with leading zeros
  if len_x < len_y
    bin_x = '0' * (len_y - len_x) + bin_x
  elsif len_y < len_x
    bin_y = '0' * (len_x - len_y) + bin_y
  end

  # Compare each bit and count the differences
  distance = 0
  (0...[len_x, len_y].max).each do |i|
    distance += 1 if bin_x[i] != bin_y[i]
  end

  distance
end

# Example usage
puts hamming_distance(1, 4) # Output should be 2
puts hamming_distance(3, 1) # Output should be 1

# soltuion 2 using XOR

def hamming_distance(x, y)
  # XOR the two numbers. XOR results in a binary number where each bit is 1
  # if the corresponding bits of x and y are different, and 0 if they are the same.
  xor_result = x ^ y

  # Convert the XOR result to binary and count the number of '1's,
  # which indicates the differing bit positions.
  xor_result.to_s(2).count('1')
end

# 258. Add Digits
# Easy
# Topics
# Companies
# Hint
# Given an integer num, repeatedly add all its digits until the result has only one digit, and return it.

# Example 1:

# Input: num = 38
# Output: 2
# Explanation: The process is
# 38 --> 3 + 8 --> 11
# 11 --> 1 + 1 --> 2
# Since 2 has only one digit, return it.
# Example 2:

# Input: num = 0
# Output: 0

# Constraints:

# 0 <= num <= 231 - 1

# solution 1

def add_digits(num)
  while num >= 10 # Continue until the number is a single digit
    sum = 0

    # Split the number into digits and sum them
    num.to_s.each_char do |digit|
      sum += digit.to_i
    end

    # Set num to the new sum
    num = sum
  end

  num
end

# 231. Power of Two
# Easy
# Topics
# Companies
# Given an integer n, return true if it is a power of two. Otherwise, return false.

# An integer n is a power of two, if there exists an integer x such that n == 2x.

# Example 1:

# Input: n = 1
# Output: true
# Explanation: 20 = 1
# Example 2:

# Input: n = 16
# Output: true
# Explanation: 24 = 16
# Example 3:

# Input: n = 3
# Output: false

# solution 1

def is_power_of_two(n)
  return true if n == 1

  n /= 2 until n.odd? || n == 2

  if n.odd?
    false
  elsif n == 2
    true
  end
end

# solution 2 refactor

def is_power_of_two(n)
  # Edge case: if n is less than or equal to 0, it cannot be a power of two.
  return false if n <= 0

  # Keep dividing n by 2 as long as it's even and greater than 1.
  n /= 2 while n > 1 && n.even?

  # If n is reduced to 1, it was a power of two.
  n == 1
end

# 278. First Bad Version
# Easy
# Topics
# Companies
# You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.

# Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.

# You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.

# Example 1:

# Input: n = 5, bad = 4
# Output: 4
# Explanation:
# call isBadVersion(3) -> false
# call isBadVersion(5) -> true
# call isBadVersion(4) -> true
# Then 4 is the first bad version.
# Example 2:

# Input: n = 1, bad = 1
# Output: 1

# Constraints:

# 1 <= bad <= n <= 231 - 1

# solution 1

def first_bad_version(n)
  left = 1
  right = n

  while left < right
    mid = left + (right - left) / 2

    if is_bad_version(mid)
      right = mid # The first bad version is at mid or before it
    else
      left = mid + 1 # The first bad version is after mid
    end
  end

  left # Left will point to the first bad version
end

# 228. Summary Ranges
# Easy
# Topics
# Companies
# You are given a sorted unique integer array nums.

# A range [a,b] is the set of all integers from a to b (inclusive).

# Return the smallest sorted list of ranges that cover all the numbers in the array exactly. That is, each element of nums is covered by exactly one of the ranges, and there is no integer x such that x is in one of the ranges but not in nums.

# Each range [a,b] in the list should be output as:

# "a->b" if a != b
# "a" if a == b

# Example 1:

# Input: nums = [0,1,2,4,5,7]
# Output: ["0->2","4->5","7"]
# Explanation: The ranges are:
# [0,2] --> "0->2"
# [4,5] --> "4->5"
# [7,7] --> "7"
# Example 2:

# Input: nums = [0,2,3,4,6,8,9]
# Output: ["0","2->4","6","8->9"]
# Explanation: The ranges are:
# [0,0] --> "0"
# [2,4] --> "2->4"
# [6,6] --> "6"
# [8,9] --> "8->9"

# Constraints:

# 0 <= nums.length <= 20
# -231 <= nums[i] <= 231 - 1
# All the values of nums are unique.
# nums is sorted in ascending order.

# solution 1

def summary_ranges(nums)
  answer = []
  range = []
  nums.each_with_index do |num, i|
    if range.length <= 0 && num + 1 == nums[i + 1]
      range.push(num)
    elsif range.length <= 0 && num + 1 != nums[i + 1]
      range.push(num)
      answer.push(range.join(''))
      range = []
    elsif num + 1 != nums[i + 1]
      range.push(num)
      answer.push(range.join('->'))
      range = []
    end
  end
  answer
end

# solution 1 refactored

def summary_ranges(nums)
  answer = []
  start = 0

  nums.each_with_index do |num, i|
    # If the next number is not consecutive or we've reached the end
    next unless i == nums.length - 1 || nums[i + 1] != num + 1

    if start == i
      answer.push("#{nums[start]}")
    else
      answer.push("#{nums[start]}->#{num}")
    end
    start = i + 1
  end

  answer
end

# solution 2

def summary_ranges(nums)
  return [] if nums.empty?

  start = nums.first
  answer = []

  nums.each_cons(2) do |a, b|
    if b != a + 1
      answer << (start == a ? "#{start}" : "#{start}->#{a}")
      start = b
    end
  end

  answer << (start == nums.last ? "#{start}" : "#{start}->#{nums.last}")
  answer
end

# 292. Nim Game
# Easy
# Topics
# Companies
# Hint
# You are playing the following Nim Game with your friend:

# Initially, there is a heap of stones on the table.
# You and your friend will alternate taking turns, and you go first.
# On each turn, the person whose turn it is will remove 1 to 3 stones from the heap.
# The one who removes the last stone is the winner.
# Given n, the number of stones in the heap, return true if you can win the game assuming both you and your friend play optimally, otherwise return false.

 

# Example 1:

# Input: n = 4
# Output: false
# Explanation: These are the possible outcomes:
# 1. You remove 1 stone. Your friend removes 3 stones, including the last stone. Your friend wins.
# 2. You remove 2 stones. Your friend removes 2 stones, including the last stone. Your friend wins.
# 3. You remove 3 stones. Your friend removes the last stone. Your friend wins.
# In all outcomes, your friend wins.
# Example 2:

# Input: n = 1
# Output: true
# Example 3:

# Input: n = 2
# Output: true
 

# Constraints:

# 1 <= n <= 231 - 1

# solution 1

def can_win_nim(n)
    n % 4 != 0
end
